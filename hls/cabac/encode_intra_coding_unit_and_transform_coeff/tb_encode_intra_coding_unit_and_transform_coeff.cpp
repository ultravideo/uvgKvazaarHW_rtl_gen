/*****************************************************************************
 * This file is part of uvgKvazaarHW.
 *
 * Copyright (c) 2025, Tampere University, ITU/ISO/IEC, project contributors
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice, this
 *   list of conditions and the following disclaimer in the documentation and/or
 *   other materials provided with the distribution.
 *
 * * Neither the name of the Tampere University or ITU/ISO/IEC nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * INCLUDING NEGLIGENCE OR OTHERWISE ARISING IN ANY WAY OUT OF THE USE OF THIS
 ****************************************************************************/

#include "cabac.h"
#include <mc_scverify.h>
#include <string.h>
#include <time.h>
#include <vector>

using namespace std;

#define MAX_DEPTH 3
#define MIN_SIZE 3
#define LCU_WIDTH (1 << (MIN_SIZE + MAX_DEPTH))
#define LCU_LUMA_SIZE (LCU_WIDTH * LCU_WIDTH)
#define LCU_CHROMA_SIZE (LCU_WIDTH * LCU_WIDTH >> 2)

void encode_intra_coding_unit_and_transform_coeff(cabac_chan &cabac_write, encode_config_chan &config_in, ac_channel< ac_int< 32 + 16 + 16 + 8 + 2 + 5, false > > &cabac_main_config,
                                                  ac_channel< ac_int< 1, false > > &cabac_done, cu_info lcu[16 * 16 * LCU_COUNT], cu_info_simple lcu_top[16 * LCU_COUNT],
                                                  cu_info_simple lcu_left[16 * LCU_COUNT], ac_int< 1, false > *active);

cu_info lcu_golden1[16 * 16] = {
    0x80002, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x80000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x0, 0x0,     0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x2, 0x2, 0x2, 0x2,
    0x2,     0x2, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,     0x0, 0x0, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,     0x0, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x0, 0x0,
    0x0,     0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x2, 0x2,     0x2, 0x2, 0x2, 0x2, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x2, 0x2, 0x2,     0x2, 0x2, 0x2, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0,     0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,     0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x80002, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x1, 0x1, 0x1, 0x1,
    0x1,     0x1, 0x1, 0x1, 0x2, 0x2, 0x2, 0x2, 0x2,     0x2, 0x2, 0x2, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,     0x2, 0x2, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x2,
    0x2,     0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x1, 0x1,     0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x1, 0x1, 0x1,     0x1, 0x1, 0x1, 0x1, 0x1, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
    0x2,     0x2, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,     0x1, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,     0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
};

cu_info_simple lcu_top_golden1[16] = {
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
};

cu_info_simple lcu_left_golden1[16] = {
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
};

uint_32 golden_conf1[] = {0x00080000, 0x00000020, 0x3801};

cabac_val golden1[] = {0x010001b, 0x010001c, 0x010001c, 0x023, 0x043, 0x043, 0x010023b};

cu_info lcu_golden2[16 * 16] = {
    0x80000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0,     0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0,     0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0,     0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
    0x1,     0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
    0x1,     0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
    0x1,     0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
};

cu_info_simple lcu_top_golden2[16] = {
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x2,
    0x2,
    0x2,
    0x2,
    0x2,
    0x2,
    0x2,
    0x2,
};

cu_info_simple lcu_left_golden2[16] = {
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
};

cabac_val golden2[] = {0x010001b, 0x010001c, 0x01c, 0x023, 0x043, 0x043, 0x023b};

cu_info lcu_golden3[16 * 16] = {
    0x20080, 0x80, 0x80, 0x80, 0x40, 0x40, 0x40, 0x40, 0x20000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80, 0x80, 0x80, 0x80, 0x40, 0x40, 0x40, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x81,    0x81, 0x81, 0x81, 0x40, 0x40, 0x40, 0x40, 0x0,        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x81, 0x81, 0x81, 0x81, 0x40, 0x40, 0x40, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x40,    0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x0,        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x40,    0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x0,        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x80001, 0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x1000000,  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x1,     0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x0,        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x1,     0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x0,        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x1,     0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x0,        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
};

cu_info_simple lcu_top_golden3[16] = {
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
};

cu_info_simple lcu_left_golden3[16] = {
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
};

cabac_val golden3[] = {0x010001b, 0x01c, 0x023, 0x043, 0x043, 0x023b};

cu_info lcu_golden4[16 * 16] = {
    0x20000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80000,  0x0,  0x0,  0x0,  0x0,        0x0,  0x0,  0x0,  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,      0x0,  0x0,  0x0,  0x0,        0x0,  0x0,  0x0,  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,      0x0,  0x0,  0x0,  0x0,        0x0,  0x0,  0x0,  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,      0x0,  0x0,  0x0,  0x0,        0x0,  0x0,  0x0,  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x21000001, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x41,     0x41, 0x41, 0x41, 0x10840061, 0x61, 0x61, 0x61, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x41, 0x41, 0x41, 0x41, 0x61, 0x61, 0x61, 0x61,
    0x1,        0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x41,     0x41, 0x41, 0x41, 0x61,       0x61, 0x61, 0x61, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x41, 0x41, 0x41, 0x41, 0x61, 0x61, 0x61, 0x61,
    0x1,        0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x840061, 0x61, 0x61, 0x61, 0x10840060, 0x60, 0x60, 0x60, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x61, 0x61, 0x61, 0x61, 0x60, 0x60, 0x60, 0x60,
    0x1,        0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x61,     0x61, 0x61, 0x61, 0x60,       0x60, 0x60, 0x60, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x61, 0x61, 0x61, 0x61, 0x60, 0x60, 0x60, 0x60,
};

cu_info_simple lcu_top_golden4[16] = {
    0x1,
    0x1,
    0x1,
    0x1,
    0x1,
    0x1,
    0x1,
    0x1,
    0x1,
    0x1,
    0x1,
    0x1,
    0x1,
    0x1,
    0x1,
    0x1,
};

cu_info_simple lcu_left_golden4[16] = {
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
};

uint_32 golden_conf4[] = {0x10840060, 0x00300030, 0x2, 0x10840060, 0x00300030, 0x102, 0x10840060, 0x00300030, 0x202};

cabac_val golden4[] = {0x010001b, 0x010001c, 0x01c, 0x023, 0x0100043, 0x0100043, 0x010023b};

cu_info lcu_golden5[16 * 16] = {
    0x848040,   0x8040, 0x8040,   0x8040, 0x848053,   0x8053, 0x8053,   0x8053, 0x21088000, 0x8000, 0x8000,  0x8000, 0x8000,  0x8000, 0x8000,  0x8000, 0x8040,   0x8040, 0x8040,  0x8040,
    0x8053,     0x8053, 0x8053,   0x8053, 0x8000,     0x8000, 0x8000,   0x8000, 0x8000,     0x8000, 0x8000,  0x8000, 0x8040,  0x8040, 0x8040,  0x8040, 0x8053,   0x8053, 0x8053,  0x8053,
    0x8000,     0x8000, 0x8000,   0x8000, 0x8000,     0x8000, 0x8000,   0x8000, 0x8040,     0x8040, 0x8040,  0x8040, 0x8053,  0x8053, 0x8053,  0x8053, 0x8000,   0x8000, 0x8000,  0x8000,
    0x8000,     0x8000, 0x8000,   0x8000, 0x428092,   0x8092, 0x28092,  0x8092, 0x808e,     0x8094, 0x28093, 0x8093, 0x8000,  0x8000, 0x8000,  0x8000, 0x8000,   0x8000, 0x8000,  0x8000,
    0x8092,     0x8092, 0x8092,   0x8092, 0x8080,     0x8094, 0x8093,   0x8093, 0x8000,     0x8000, 0x8000,  0x8000, 0x8000,  0x8000, 0x8000,  0x8000, 0x28092,  0x8092, 0x28091, 0x8091,
    0x28091,    0x8091, 0x28091,  0x8091, 0x8000,     0x8000, 0x8000,   0x8000, 0x8000,     0x8000, 0x8000,  0x8000, 0x8092,  0x8092, 0x8091,  0x8091, 0x8091,   0x8091, 0x8091,  0x8091,
    0x8000,     0x8000, 0x8000,   0x8000, 0x8000,     0x8000, 0x8000,   0x8000, 0x10048052, 0x8052, 0x8052,  0x8052, 0x28080, 0x8080, 0x8091,  0x8091, 0x48040,  0x8040, 0x8040,  0x8040,
    0x28093,    0x8093, 0x428093, 0x8093, 0x8052,     0x8052, 0x8052,   0x8052, 0x8080,     0x8080, 0x8080,  0x8080, 0x8040,  0x8040, 0x8040,  0x8040, 0x8093,   0x8093, 0x8093,  0x8093,
    0x8052,     0x8052, 0x8052,   0x8052, 0x2808d,    0x808d, 0x40808f, 0x808f, 0x8040,     0x8040, 0x8040,  0x8040, 0x2808a, 0x808a, 0x28093, 0x8093, 0x8052,   0x8052, 0x8052,  0x8052,
    0x808d,     0x808d, 0x808f,   0x808f, 0x8040,     0x8040, 0x8040,   0x8040, 0x808a,     0x808a, 0x8093,  0x8093, 0x48051, 0x8051, 0x8051,  0x8051, 0x848052, 0x8052, 0x8052,  0x8052,
    0x10848050, 0x8050, 0x8050,   0x8050, 0x10848053, 0x8053, 0x8053,   0x8053, 0x8051,     0x8051, 0x8051,  0x8051, 0x8052,  0x8052, 0x8052,  0x8052, 0x8050,   0x8050, 0x8050,  0x8050,
    0x8053,     0x8053, 0x8053,   0x8053, 0x8051,     0x8051, 0x8051,   0x8051, 0x8052,     0x8052, 0x8052,  0x8052, 0x8050,  0x8050, 0x8050,  0x8050, 0x8053,   0x8053, 0x8053,  0x8053,
    0x8051,     0x8051, 0x8051,   0x8051, 0x8052,     0x8052, 0x8052,   0x8052, 0x8050,     0x8050, 0x8050,  0x8050, 0x8053,  0x8053, 0x8053,  0x8053,
};

cu_info_simple lcu_top_golden5[16] = {
    0x55,
    0x55,
    0x55,
    0x55,
    0x40,
    0x40,
    0x40,
    0x40,
    0xd,
    0xd,
    0xd,
    0xd,
    0xd,
    0xd,
    0xd,
    0xd,
};

cu_info_simple lcu_left_golden5[16] = {
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
};

uint_32 golden_conf5[] = {0x00848040, 0x00000000, 0x402, 0x00848040, 0x00000000, 0x502, 0x00848053, 0x00000010, 0x402, 0x00848053, 0x00000010, 0x502, 0x00028091, 0x00180008, 0x403};

cabac_val golden5[] = {0x010001b, 0x01b, 0x01b, 0x01b, 0x01c, 0x0111401a, 0x0101401a, 0x0d1401a, 0x023, 0x0100043, 0x043, 0x0100243, 0x010003b, 0x0100243, 0x010003b, 0x0100243, 0x0443, 0x010003b};

CCS_MAIN(int argc, char *argv[]) {
  srand(time(NULL));

  static cabac_chan cabac_write;
  static encode_config_chan encode_transform_config;
  static ac_channel< ac_int< 32 + 16 + 16 + 8 + 2 + 5, false > > cabac_main_config;
  static ac_channel< ac_int< 1, false > > cabac_done;
  static cu_info lcu[16 * 16 * LCU_COUNT];
  static cu_info_simple lcu_top[16 * LCU_COUNT];
  static cu_info_simple lcu_left[16 * LCU_COUNT];
  static ac_int< 1, false > active;

  int RUN_TEST_CASE = 0; // 1-5 0=all

  int tests_passed = 1;

  if (RUN_TEST_CASE == 1 || RUN_TEST_CASE == 0) {
    /*
    CABAC_BIN, value 1, name prev_intra_luma_pred_flag, func encode_intra_coding_unit
    CABAC_BIN_EP, value 1, name mpm_idx, func encode_intra_coding_unit
    CABAC_BIN_EP, value 1, name mpm_idx, func encode_intra_coding_unit
    CABAC_BIN, value 0, name intra_chroma_pred_mode, func encode_intra_coding_unit
    CABAC_BIN, value 0, name cbf_cb, func encode_transform_coeff
    CABAC_BIN, value 0, name cbf_cr, func encode_transform_coeff
    CABAC_BIN, value 1, name cbf_luma, func encode_transform_coeff
    */
    printf("Test case 1\n");

    ac_int< 5, false > ctu_id = rand() % 16;
    {
      memset(lcu, 0, sizeof(lcu));
      memset(lcu_top, 0, sizeof(lcu_top));
      memset(lcu_left, 0, sizeof(lcu_left));
      for (int a = 0; a < 16 * 16; a++) {
        lcu[a + 16 * 16 * ctu_id] = lcu_golden1[a];
      }
      for (int a = 0; a < 16; a++) {
        lcu_top[a + 16 * ctu_id] = lcu_top_golden1[a];
        lcu_left[a + 16 * ctu_id] = lcu_left_golden1[a];
      }

      encode_config_val config_temp = 0;

      config_temp.set_slc(0, (ac_int< 16, false >)0x120);
      config_temp.set_slc(16, (ac_int< 16, false >)0);
      config_temp.set_slc(16 + 16, (ac_int< 16, false >)0x20);
      config_temp.set_slc(16 + 16 + 16, (ac_int< 16, false >)0);
      config_temp.set_slc(16 + 16 + 16 + 16, (ac_int< 8, false >)1);
      config_temp.set_slc(16 + 16 + 16 + 16 + 8, (ac_int< 1, false >)0);
      config_temp.set_slc(16 + 16 + 16 + 16 + 8 + 1, (ac_int< 8, false >)0x20);
      config_temp.set_slc(16 + 16 + 16 + 16 + 8 + 1 + 8, (ac_int< 8, false >)0x20);
      config_temp[16 + 16 + 16 + 16 + 8 + 1 + 8 + 8] = 1;
      config_temp.set_slc(16 + 16 + 16 + 16 + 8 + 1 + 8 + 8 + 1 + 3, (ac_int< 8, false >)0x0);
      config_temp.set_slc(16 + 16 + 16 + 16 + 8 + 1 + 8 + 8 + 1 + 3 + 8, (ac_int< 8, false >)0x0);
      // CTU_ID
      config_temp.set_slc(16 + 16 + 16 + 16 + 8 + 1 + 8 + 8 + 1 + 3 + 8 + 8, (ac_int< 5, false >)ctu_id);
      // active
      config_temp.set_slc(16 + 16 + 16 + 16 + 8 + 1 + 8 + 8 + 1 + 3 + 8 + 8 + 5, (ac_int< 1, false >)0x1);

      encode_transform_config.write(config_temp);

      cabac_done.write(1);

      CCS_DESIGN(encode_intra_coding_unit_and_transform_coeff)(cabac_write, encode_transform_config, cabac_main_config, cabac_done, lcu, lcu_top, lcu_left, &active);

      printf("cabac_main_config:\n");
      while (cabac_main_config.available(1)) {
        static int i = 0;
        ac_int< 32 + 16 + 16 + 8 + 2 + 5, false > temp = cabac_main_config.read();
        if (golden_conf1[i] != temp.slc< 32 >(0) && golden_conf1[i + 1] != temp.slc< 32 >(32) && golden_conf1[i + 2].set_slc(10, ctu_id) != temp.slc< 15 >(64)) {
          tests_passed = 0;
        }
        i = i + 3;
        printf("0x%x%08x%08x\n", temp.slc< 15 >(64), temp.slc< 32 >(32), temp.slc< 32 >(0));
      }
      if (cabac_main_config.available(1) != 0) {
        tests_passed = 0;
      }
      printf("cabac_write:\n");
      while (cabac_write.available(1)) {
        static int i = 0;
        cabac_val temp = cabac_write.read();
        if (temp != golden1[i++]) {
          tests_passed = 0;
        }
        printf("0x%x%x\n", temp.slc< 4 >(32), temp.slc< 32 >(0));
      }
      if (cabac_write.available(1) != 0) {
        tests_passed = 0;
      }
    }
  }

  if (tests_passed == 0) {
    cout << "Testcase 1 failed" << endl;
    goto ERR;
  }

  if (RUN_TEST_CASE == 2 || RUN_TEST_CASE == 0) {
    /*
    CABAC_BIN, value 1, name prev_intra_luma_pred_flag, func encode_intra_coding_unit
    CABAC_BIN_EP, value 1, name mpm_idx, func encode_intra_coding_unit
    CABAC_BIN_EP, value 1, name mpm_idx, func encode_intra_coding_unit
    CABAC_BIN, value 0, name intra_chroma_pred_mode, func encode_intra_coding_unit
    CABAC_BIN, value 0, name cbf_cb, func encode_transform_coeff
    CABAC_BIN, value 0, name cbf_cr, func encode_transform_coeff
    CABAC_BIN, value 0, name cbf_luma, func encode_transform_coeff
    */
    printf("Test case 2\n");

    ac_int< 5, false > ctu_id = rand() % 16;
    {
      // printf("CTU_ID %d\n",ctu_id);
      memset(lcu, 0, sizeof(lcu));
      memset(lcu_top, 0, sizeof(lcu_top));
      memset(lcu_left, 0, sizeof(lcu_left));
      for (int a = 0; a < 16 * 16; a++) {
        lcu[a + 16 * 16 * ctu_id] = lcu_golden2[a];
      }
      for (int a = 0; a < 16; a++) {
        lcu_top[a + 16 * ctu_id] = lcu_top_golden2[a];
        lcu_left[a + 16 * ctu_id] = lcu_left_golden2[a];
      }

      encode_config_val config_temp = 0;

      config_temp.set_slc(0, (ac_int< 16, false >)0x140);
      config_temp.set_slc(16, (ac_int< 16, false >)0x20);
      config_temp.set_slc(16 + 16, (ac_int< 16, false >)0);
      config_temp.set_slc(16 + 16 + 16, (ac_int< 16, false >)0x20);
      config_temp.set_slc(16 + 16 + 16 + 16, (ac_int< 8, false >)1);
      config_temp.set_slc(16 + 16 + 16 + 16 + 8, (ac_int< 1, false >)0);
      config_temp.set_slc(16 + 16 + 16 + 16 + 8 + 1, (ac_int< 8, false >)0x20);
      config_temp.set_slc(16 + 16 + 16 + 16 + 8 + 1 + 8, (ac_int< 8, false >)0x20);
      config_temp[16 + 16 + 16 + 16 + 8 + 1 + 8 + 8] = 1;
      config_temp.set_slc(16 + 16 + 16 + 16 + 8 + 1 + 8 + 8 + 1 + 3, (ac_int< 8, false >)0x1);
      config_temp.set_slc(16 + 16 + 16 + 16 + 8 + 1 + 8 + 8 + 1 + 3 + 8, (ac_int< 8, false >)0x0);
      // CTU_ID
      config_temp.set_slc(16 + 16 + 16 + 16 + 8 + 1 + 8 + 8 + 1 + 3 + 8 + 8, (ac_int< 5, false >)ctu_id);
      // active
      config_temp.set_slc(16 + 16 + 16 + 16 + 8 + 1 + 8 + 8 + 1 + 3 + 8 + 8 + 5, (ac_int< 1, false >)0x1);

      encode_transform_config.write(config_temp);

      CCS_DESIGN(encode_intra_coding_unit_and_transform_coeff)(cabac_write, encode_transform_config, cabac_main_config, cabac_done, lcu, lcu_top, lcu_left, &active);

      if (cabac_main_config.available(1) != 0) {
        tests_passed = 0;
      }
      printf("cabac_write:\n");
      while (cabac_write.available(1)) {
        static int i = 0;
        cabac_val temp = cabac_write.read();
        if (temp != golden2[i++]) {
          tests_passed = 0;
        }
        printf("0x%x%x\n", temp.slc< 4 >(32), temp.slc< 32 >(0));
      }
      if (cabac_write.available(1) != 0) {
        tests_passed = 0;
      }
    }
  }

  if (tests_passed == 0) {
    cout << "Testcase 2 failed" << endl;
    goto ERR;
  }

  if (RUN_TEST_CASE == 3 || RUN_TEST_CASE == 0) {
    /*
    CABAC_BIN, value 1, name prev_intra_luma_pred_flag, func encode_intra_coding_unit
    CABAC_BIN_EP, value 0, name mpm_idx, func encode_intra_coding_unit
    CABAC_BIN, value 0, name intra_chroma_pred_mode, func encode_intra_coding_unit
    CABAC_BIN, value 0, name cbf_cb, func encode_transform_coeff
    CABAC_BIN, value 0, name cbf_cr, func encode_transform_coeff
    CABAC_BIN, value 0, name cbf_luma, func encode_transform_coeff
    */
    printf("Test case 3\n");

    ac_int< 5, false > ctu_id = rand() % 16;
    {
      memset(lcu, 0, sizeof(lcu));
      memset(lcu_top, 0, sizeof(lcu_top));
      memset(lcu_left, 0, sizeof(lcu_left));
      for (int a = 0; a < 16 * 16; a++) {
        lcu[a + 16 * 16 * ctu_id] = lcu_golden3[a];
      }
      for (int a = 0; a < 16; a++) {
        lcu_top[a + 16 * ctu_id] = lcu_top_golden3[a];
        lcu_left[a + 16 * ctu_id] = lcu_left_golden3[a];
      }

      encode_config_val config_temp = 0;

      config_temp.set_slc(0, (ac_int< 16, false >)0x0);
      config_temp.set_slc(16, (ac_int< 16, false >)0x8);
      config_temp.set_slc(16 + 16, (ac_int< 16, false >)0);
      config_temp.set_slc(16 + 16 + 16, (ac_int< 16, false >)0x8);
      config_temp.set_slc(16 + 16 + 16 + 16, (ac_int< 8, false >)3);
      config_temp.set_slc(16 + 16 + 16 + 16 + 8, (ac_int< 1, false >)0);
      config_temp.set_slc(16 + 16 + 16 + 16 + 8 + 1, (ac_int< 8, false >)0x20);
      config_temp.set_slc(16 + 16 + 16 + 16 + 8 + 1 + 8, (ac_int< 8, false >)0x20);
      config_temp[16 + 16 + 16 + 16 + 8 + 1 + 8 + 8] = 1;
      config_temp.set_slc(16 + 16 + 16 + 16 + 8 + 1 + 8 + 8 + 1 + 3, (ac_int< 8, false >)0x1);
      config_temp.set_slc(16 + 16 + 16 + 16 + 8 + 1 + 8 + 8 + 1 + 3 + 8, (ac_int< 8, false >)0x40);
      // CTU_ID
      config_temp.set_slc(16 + 16 + 16 + 16 + 8 + 1 + 8 + 8 + 1 + 3 + 8 + 8, (ac_int< 5, false >)ctu_id);
      // active
      config_temp.set_slc(16 + 16 + 16 + 16 + 8 + 1 + 8 + 8 + 1 + 3 + 8 + 8 + 5, (ac_int< 1, false >)0x1);

      encode_transform_config.write(config_temp);

      CCS_DESIGN(encode_intra_coding_unit_and_transform_coeff)(cabac_write, encode_transform_config, cabac_main_config, cabac_done, lcu, lcu_top, lcu_left, &active);

      if (cabac_main_config.available(1) != 0) {
        tests_passed = 0;
      }
      printf("cabac_write:\n");
      while (cabac_write.available(1)) {
        static int i = 0;
        cabac_val temp = cabac_write.read();
        if (temp != golden3[i++]) {
          tests_passed = 0;
        }
        printf("0x%x%x\n", temp.slc< 4 >(32), temp.slc< 32 >(0));
      }
      if (cabac_write.available(1) != 0) {
        tests_passed = 0;
      }
    }
  }

  if (tests_passed == 0) {
    cout << "Testcase 3 failed" << endl;
    goto ERR;
  }

  if (RUN_TEST_CASE == 4 || RUN_TEST_CASE == 0) {
    /*
    CABAC_BIN, value 1, name prev_intra_luma_pred_flag, func encode_intra_coding_unit
    CABAC_BIN_EP, value 1, name mpm_idx, func encode_intra_coding_unit
    CABAC_BIN_EP, value 0, name mpm_idx, func encode_intra_coding_unit
    CABAC_BIN, value 0, name intra_chroma_pred_mode, func encode_intra_coding_unit
    CABAC_BIN, value 1, name cbf_cb, func encode_transform_coeff
    CABAC_BIN, value 1, name cbf_cr, func encode_transform_coeff
    CABAC_BIN, value 1, name cbf_luma, func encode_transform_coeff
    */
    printf("Test case 4\n");

    ac_int< 5, false > ctu_id = rand() % 16;
    {
      memset(lcu, 0, sizeof(lcu));
      memset(lcu_top, 0, sizeof(lcu_top));
      memset(lcu_left, 0, sizeof(lcu_left));
      for (int a = 0; a < 16 * 16; a++) {
        lcu[a + 16 * 16 * ctu_id] = lcu_golden4[a];
      }
      for (int a = 0; a < 16; a++) {
        lcu_top[a + 16 * ctu_id] = lcu_top_golden4[a];
        lcu_left[a + 16 * ctu_id] = lcu_left_golden4[a];
      }

      encode_config_val config_temp = 0;

      config_temp.set_slc(0, (ac_int< 16, false >)0x2f0);
      config_temp.set_slc(16, (ac_int< 16, false >)0x30);
      config_temp.set_slc(16 + 16, (ac_int< 16, false >)0x30);
      config_temp.set_slc(16 + 16 + 16, (ac_int< 16, false >)0x30);
      config_temp.set_slc(16 + 16 + 16 + 16, (ac_int< 8, false >)2);
      config_temp.set_slc(16 + 16 + 16 + 16 + 8, (ac_int< 1, false >)0);
      config_temp.set_slc(16 + 16 + 16 + 16 + 8 + 1, (ac_int< 8, false >)0x20);
      config_temp.set_slc(16 + 16 + 16 + 16 + 8 + 1 + 8, (ac_int< 8, false >)0x20);
      config_temp[16 + 16 + 16 + 16 + 8 + 1 + 8 + 8] = 1;
      config_temp.set_slc(16 + 16 + 16 + 16 + 8 + 1 + 8 + 8 + 1 + 3, (ac_int< 8, false >)0x20);
      config_temp.set_slc(16 + 16 + 16 + 16 + 8 + 1 + 8 + 8 + 1 + 3 + 8, (ac_int< 8, false >)0x40);
      // CTU_ID
      config_temp.set_slc(16 + 16 + 16 + 16 + 8 + 1 + 8 + 8 + 1 + 3 + 8 + 8, (ac_int< 5, false >)ctu_id);
      // active
      config_temp.set_slc(16 + 16 + 16 + 16 + 8 + 1 + 8 + 8 + 1 + 3 + 8 + 8 + 5, (ac_int< 1, false >)0x1);

      encode_transform_config.write(config_temp);
      cabac_done.write(1);
      cabac_done.write(1);
      cabac_done.write(1);

      CCS_DESIGN(encode_intra_coding_unit_and_transform_coeff)(cabac_write, encode_transform_config, cabac_main_config, cabac_done, lcu, lcu_top, lcu_left, &active);

      printf("cabac_main_config:\n");
      while (cabac_main_config.available(1)) {
        static int i = 0;
        ac_int< 32 + 16 + 16 + 8 + 2 + 5, false > temp = cabac_main_config.read();
        if (golden_conf4[i] != temp.slc< 32 >(0) && golden_conf4[i + 1] != temp.slc< 32 >(32) && golden_conf4[i + 2].set_slc(10, ctu_id) != temp.slc< 15 >(64)) {
          tests_passed = 0;
        }
        i = i + 3;
        printf("0x%x%08x%08x\n", temp.slc< 15 >(64), temp.slc< 32 >(32), temp.slc< 32 >(0));
      }

      if (cabac_main_config.available(1) != 0) {
        tests_passed = 0;
      }
      printf("cabac_write:\n");
      while (cabac_write.available(1)) {
        static int i = 0;
        cabac_val temp = cabac_write.read();
        if (temp != golden4[i++]) {
          tests_passed = 0;
        }
        printf("0x%x%x\n", temp.slc< 4 >(32), temp.slc< 32 >(0));
      }
      if (cabac_write.available(1) != 0) {
        tests_passed = 0;
      }
    }
  }

  if (tests_passed == 0) {
    cout << "Testcase 4 failed" << endl;
    goto ERR;
  }

  if (RUN_TEST_CASE == 5 || RUN_TEST_CASE == 0) {
    printf("Test case 5\n");

    ac_int< 5, false > ctu_id = rand() % 16;
    {
      memset(lcu, 0, sizeof(lcu));
      memset(lcu_top, 0, sizeof(lcu_top));
      memset(lcu_left, 0, sizeof(lcu_left));
      for (int a = 0; a < 16 * 16; a++) {
        lcu[a + 16 * 16 * ctu_id] = lcu_golden5[a];
      }
      for (int a = 0; a < 16; a++) {
        lcu_top[a + 16 * ctu_id] = lcu_top_golden5[a];
        lcu_left[a + 16 * ctu_id] = lcu_left_golden5[a];
      }

      encode_config_val config_temp = 0;

      config_temp.set_slc(0, (ac_int< 16, false >)0);
      config_temp.set_slc(16, (ac_int< 16, false >)0);

      config_temp.set_slc(16 + 16, (ac_int< 16, false >)0);
      config_temp.set_slc(16 + 16 + 16, (ac_int< 16, false >)0);

      config_temp.set_slc(16 + 16 + 16 + 16, (ac_int< 8, false >)1);

      config_temp.set_slc(16 + 16 + 16 + 16 + 8, (ac_int< 1, false >)0);
      config_temp.set_slc(16 + 16 + 16 + 16 + 8 + 1, (ac_int< 8, false >)32);
      config_temp.set_slc(16 + 16 + 16 + 16 + 8 + 1 + 8, (ac_int< 8, false >)32);

      config_temp[16 + 16 + 16 + 16 + 8 + 1 + 8 + 8] = 1;

      config_temp.set_slc(16 + 16 + 16 + 16 + 8 + 1 + 8 + 8 + 1, (ac_int< 3, false >)0x4);

      config_temp.set_slc(16 + 16 + 16 + 16 + 8 + 1 + 8 + 8 + 1 + 3, (ac_int< 8, false >)0x0);
      config_temp.set_slc(16 + 16 + 16 + 16 + 8 + 1 + 8 + 8 + 1 + 3 + 8, (ac_int< 8, false >)64);
      // CTU_ID
      config_temp.set_slc(16 + 16 + 16 + 16 + 8 + 1 + 8 + 8 + 1 + 3 + 8 + 8, (ac_int< 5, false >)ctu_id);
      // active
      config_temp.set_slc(16 + 16 + 16 + 16 + 8 + 1 + 8 + 8 + 1 + 3 + 8 + 8 + 5, (ac_int< 1, false >)0x1);

      encode_transform_config.write(config_temp);

      cabac_done.write(1);
      cabac_done.write(1);
      cabac_done.write(1);
      cabac_done.write(1);
      cabac_done.write(1);

      CCS_DESIGN(encode_intra_coding_unit_and_transform_coeff)(cabac_write, encode_transform_config, cabac_main_config, cabac_done, lcu, lcu_top, lcu_left, &active);

      printf("cabac_main_config:\n");
      while (cabac_main_config.available(1)) {
        static int i = 0;
        ac_int< 32 + 16 + 16 + 8 + 2 + 5, false > temp = cabac_main_config.read();
        if (golden_conf5[i] != temp.slc< 32 >(0) && golden_conf5[i + 1] != temp.slc< 32 >(32) && golden_conf5[i + 2].set_slc(10, ctu_id) != temp.slc< 15 >(64)) {
          tests_passed = 0;
        }
        i = i + 3;
        printf("0x%x%08x%08x\n", temp.slc< 15 >(64), temp.slc< 32 >(32), temp.slc< 32 >(0));
      }
      if (cabac_main_config.available(1) != 0) {
        tests_passed = 0;
      }
      printf("cabac_write:\n");
      while (cabac_write.available(1)) {
        static int i = 0;
        cabac_val temp = cabac_write.read();
        if (temp != golden5[i++]) {
          tests_passed = 0;
        }
        printf("0x%x%x\n", temp.slc< 4 >(32), temp.slc< 32 >(0));
      }
      if (cabac_write.available(1) != 0) {
        tests_passed = 0;
      }
    }
  }

  if (tests_passed == 0) {
    cout << "Testcase 5 failed" << endl;
    goto ERR;
  }

ERR:
  if (tests_passed) {
    cout << "## SIMULATION PASSED ##" << endl;
  } else {
    cout << "## SIMULATION FAILED ##" << endl;
  }

  CCS_RETURN(0);
}
