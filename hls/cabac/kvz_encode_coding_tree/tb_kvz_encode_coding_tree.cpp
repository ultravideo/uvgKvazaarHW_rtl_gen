/*****************************************************************************
 * This file is part of uvgKvazaarHW.
 *
 * Copyright (c) 2025, Tampere University, ITU/ISO/IEC, project contributors
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice, this
 *   list of conditions and the following disclaimer in the documentation and/or
 *   other materials provided with the distribution.
 *
 * * Neither the name of the Tampere University or ITU/ISO/IEC nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * INCLUDING NEGLIGENCE OR OTHERWISE ARISING IN ANY WAY OUT OF THE USE OF THIS
 ****************************************************************************/

#include "cabac.h"
#include <mc_scverify.h>
#include <vector>

using namespace std;

#define MAX_DEPTH 3
#define MIN_SIZE 3
#define LCU_WIDTH (1 << (MIN_SIZE + MAX_DEPTH))
#define LCU_LUMA_SIZE (LCU_WIDTH * LCU_WIDTH)
#define LCU_CHROMA_SIZE (LCU_WIDTH * LCU_WIDTH >> 2)

void kvz_encode_coding_tree(cabac_chan &cabac_write, ac_channel< ac_int< 32, false > > &config_in, encode_config_chan &encode_intra_config, cu_info lcu[16 * 16 * LCU_COUNT],
                            cu_info_simple lcu_top[16 * LCU_COUNT], cu_info_simple lcu_left[16 * LCU_COUNT], uint_32 *low, uint_16 *range, uint_8 *buffered_byte, uint_8 *num_buffered_bytes,
                            uint_8 *bits_left, uint_8 *stream_data, uint_8 *stream_cur_bit, uint_8 *stream_zercount, ac_int< 128, false > cabac_metas[2 * LCU_COUNT]);

void recursive_kvz_encode_coding_tree(cabac_chan &cabac_write, ac_channel< ac_int< 32, false > > &config_in, encode_config_chan &encode_intra_config, cu_info lcu[16 * 16], cu_info_simple lcu_top[16],
                                      cu_info_simple lcu_left[16]);

cu_info lcu_golden1[16 * 16] = {
    0x80000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0,     0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0,     0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0,     0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x80001, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1000000,  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x1,     0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x0,        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x1,     0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x0,        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x1,     0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x0,        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
};

cu_info_simple lcu_top_golden1[16] = {
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
};

cu_info_simple lcu_left_golden1[16] = {
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
};

cu_info lcu_golden2[16 * 16] = {
    0x20000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80000,    0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x0,        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,        0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,  0x0,
    0x21000001, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x21080021, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21,
    0x1,        0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x21,       0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21,
    0x1,        0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x21,       0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21,
    0x1,        0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x21,       0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21,
};

cu_info_simple lcu_top_golden2[16] = {
    0x1,
    0x1,
    0x1,
    0x1,
    0x1,
    0x1,
    0x1,
    0x1,
    0x1,
    0x1,
    0x1,
    0x1,
    0x1,
    0x1,
    0x1,
    0x1,
};

cu_info_simple lcu_left_golden2[16] = {
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
};

cu_info lcu_golden3[16 * 16] = {
    0x40040, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,     0x40, 0x40,     0x40, 0x40, 0x40, 0x40,     0x40, 0x40,    0x40, 0x40,
    0x40,    0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,     0x40, 0x40,     0x40, 0x40, 0x40, 0x40,     0x40, 0x40,    0x40, 0x40,
    0x40,    0x40, 0x40, 0x40, 0x40, 0x40, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x800041, 0x41, 0x41,     0x41, 0x41, 0x41, 0x41,     0x41, 0x41,    0x41, 0x41,
    0x41,    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,     0x41, 0x41,     0x41, 0x41, 0x41, 0x41,     0x41, 0x41,    0x41, 0x41,
    0x41,    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,     0x40, 0x800040, 0x40, 0x40, 0x40, 0x800040, 0x40, 0x40,    0x40, 0x40,
    0x40,    0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,     0x40, 0x40,     0x40, 0x40, 0x40, 0x40,     0x40, 0x40,    0x40, 0x40,
    0x40,    0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x41,     0x41, 0x41,     0x41, 0x41, 0x41, 0x41,     0x41, 0x40041, 0x41, 0x41,
    0x41,    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,     0x41, 0x41,     0x41, 0x41, 0x41, 0x41,     0x41, 0x41,    0x41, 0x41,
    0x41,    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,     0x41, 0x41,     0x41, 0x41, 0x41,
};

cu_info_simple lcu_top_golden3[16] = {
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
};

cu_info_simple lcu_left_golden3[16] = {
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
};

cu_info lcu_golden4[16 * 16] = {
    0x1080000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1080000,  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0,       0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0,       0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0,       0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0,       0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0,       0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0,       0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0,       0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
};

cu_info_simple lcu_top_golden4[16] = {
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
};

cu_info_simple lcu_left_golden4[16] = {
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
};

cu_info lcu_golden5[16 * 16] = {
    0x20080, 0x80, 0x80, 0x80, 0x40, 0x40, 0x40, 0x40, 0x20000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80, 0x80, 0x80, 0x80, 0x40, 0x40, 0x40, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x81,    0x81, 0x81, 0x81, 0x40, 0x40, 0x40, 0x40, 0x0,        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x81, 0x81, 0x81, 0x81, 0x40, 0x40, 0x40, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x40,    0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x0,        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x40,    0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x0,        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x80001, 0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x1000000,  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x1,     0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x0,        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x1,     0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x0,        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x1,     0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x0,        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x1,  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
};

cu_info_simple lcu_top_golden5[16] = {
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
};

cu_info_simple lcu_left_golden5[16] = {
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
    0x0,
};

CCS_MAIN(int argc, char *argv[]) {
  static cabac_chan cabac_write;
  static ac_channel< ac_int< 32, false > > config_in;
  static encode_config_chan encode_intra_config;

  static encode_config_chan golden_encode_intra_config;
  static cabac_chan golden_cabac_write;

  static cu_info lcu[16 * 16 * LCU_COUNT];
  static cu_info_simple lcu_top[17 * LCU_COUNT];
  static cu_info_simple lcu_left[17 * LCU_COUNT];

  static uint_32 low;
  static uint_16 range;
  static uint_8 buffered_byte;
  static uint_8 num_buffered_bytes;
  static uint_8 bits_left;
  static uint_8 stream_data;
  static uint_8 stream_cur_bit;
  static uint_8 stream_zercount;
  static ac_int< 128, false > cabac_metas[2 * LCU_COUNT];

  int RUN_TEST_CASE = 0; // 1-5 0=all

  int tests_passed = 1;

  if (RUN_TEST_CASE == 1 || RUN_TEST_CASE == 0) {
    for (int a = 0; a < 16 * 16; a++) {
      lcu[a] = lcu_golden1[a];
    }
    for (int a = 0; a < 16; a++) {
      lcu_top[a] = lcu_top_golden1[a];
      lcu_left[a] = lcu_left_golden1[a];
    }

    config_in.write(0x04380780);
    config_in.write(0x0);
    config_in.write(0x2c0);
    config_in.write(0x0);
    config_in.write(0x40404000);
    config_in.write(0x80004000);

    CCS_DESIGN(kvz_encode_coding_tree)
    (cabac_write, config_in, encode_intra_config, lcu, lcu_top, lcu_left, &low, &range, &buffered_byte, &num_buffered_bytes, &bits_left, &stream_data, &stream_cur_bit, &stream_zercount, cabac_metas);

    config_in.write(0x04380780);
    config_in.write(0x0);
    config_in.write(0x2c0);
    config_in.write(0x0);
    config_in.write(0x40404000);
    config_in.write(0x80004000);

    CCS_DESIGN(recursive_kvz_encode_coding_tree)(golden_cabac_write, config_in, golden_encode_intra_config, lcu, lcu_top, lcu_left);

    while (encode_intra_config.available(1)) {
      encode_config_val temp = encode_intra_config.read();
      encode_config_val golden_temp = golden_encode_intra_config.read();
      if (temp != golden_temp) {
        printf("Error: encode_intra_config");
        tests_passed = 0;
      }
    }
    while (cabac_write.available(1)) {
      cabac_val temp = cabac_write.read();
      cabac_val golden_temp = golden_cabac_write.read();
      if (temp != golden_temp) {
        printf("Error: cabac_write");
        tests_passed = 0;
      }
    }
  }

  if (RUN_TEST_CASE == 2 || RUN_TEST_CASE == 0) {

    for (int a = 0; a < 16 * 16; a++) {
      lcu[a] = lcu_golden2[a];
    }
    for (int a = 0; a < 16; a++) {
      lcu_top[a] = lcu_top_golden2[a];
      lcu_left[a] = lcu_left_golden2[a];
    }

    config_in.write(0x4380780);
    config_in.write(0x0);
    config_in.write(0x0);
    config_in.write(0x0);
    config_in.write(0x40404000);
    config_in.write(0x80004000);

    CCS_DESIGN(kvz_encode_coding_tree)
    (cabac_write, config_in, encode_intra_config, lcu, lcu_top, lcu_left, &low, &range, &buffered_byte, &num_buffered_bytes, &bits_left, &stream_data, &stream_cur_bit, &stream_zercount, cabac_metas);

    config_in.write(0x4380780);
    config_in.write(0x0);
    config_in.write(0x0);
    config_in.write(0x0);
    config_in.write(0x40404000);
    config_in.write(0x80004000);

    CCS_DESIGN(recursive_kvz_encode_coding_tree)(golden_cabac_write, config_in, golden_encode_intra_config, lcu, lcu_top, lcu_left);

    while (encode_intra_config.available(1)) {
      encode_config_val temp = encode_intra_config.read();
      encode_config_val golden_temp = golden_encode_intra_config.read();
      if (temp != golden_temp) {
        printf("Error: encode_intra_config");
        tests_passed = 0;
      }
    }
    while (cabac_write.available(1)) {
      cabac_val temp = cabac_write.read();
      cabac_val golden_temp = golden_cabac_write.read();
      if (temp != golden_temp) {
        printf("Error: cabac_write");
        tests_passed = 0;
      }
    }
  }

  if (RUN_TEST_CASE == 3 || RUN_TEST_CASE == 0) {
    for (int a = 0; a < 16 * 16; a++) {
      lcu[a] = lcu_golden3[a];
    }
    for (int a = 0; a < 16; a++) {
      lcu_top[a] = lcu_top_golden3[a];
      lcu_left[a] = lcu_left_golden3[a];
    }

    config_in.write(0x04380780);
    config_in.write(0x0);
    config_in.write(0x0);
    config_in.write(0x0);
    config_in.write(0x40404000);
    config_in.write(0x80004000);

    CCS_DESIGN(kvz_encode_coding_tree)
    (cabac_write, config_in, encode_intra_config, lcu, lcu_top, lcu_left, &low, &range, &buffered_byte, &num_buffered_bytes, &bits_left, &stream_data, &stream_cur_bit, &stream_zercount, cabac_metas);

    config_in.write(0x04380780);
    config_in.write(0x0);
    config_in.write(0x0);
    config_in.write(0x0);
    config_in.write(0x40404000);
    config_in.write(0x80004000);

    CCS_DESIGN(recursive_kvz_encode_coding_tree)(golden_cabac_write, config_in, golden_encode_intra_config, lcu, lcu_top, lcu_left);

    while (encode_intra_config.available(1)) {
      encode_config_val temp = encode_intra_config.read();
      encode_config_val golden_temp = golden_encode_intra_config.read();
      if (temp != golden_temp) {
        printf("Error: encode_intra_config");
        tests_passed = 0;
      }
    }
    while (cabac_write.available(1)) {
      cabac_val temp = cabac_write.read();
      cabac_val golden_temp = golden_cabac_write.read();
      if (temp != golden_temp) {
        printf("Error: cabac_write");
        tests_passed = 0;
      }
    }
  }

  if (RUN_TEST_CASE == 4 || RUN_TEST_CASE == 0) {
    for (int a = 0; a < 16 * 16; a++) {
      lcu[a] = lcu_golden4[a];
    }
    for (int a = 0; a < 16; a++) {
      lcu_top[a] = lcu_top_golden4[a];
      lcu_left[a] = lcu_left_golden4[a];
    }

    config_in.write(0x04380780);
    config_in.write(0x0);
    config_in.write(0x40);
    config_in.write(0x0);
    config_in.write(0x40404000);
    config_in.write(0x80004000);

    CCS_DESIGN(kvz_encode_coding_tree)
    (cabac_write, config_in, encode_intra_config, lcu, lcu_top, lcu_left, &low, &range, &buffered_byte, &num_buffered_bytes, &bits_left, &stream_data, &stream_cur_bit, &stream_zercount, cabac_metas);

    config_in.write(0x04380780);
    config_in.write(0x0);
    config_in.write(0x40);
    config_in.write(0x0);
    config_in.write(0x40404000);
    config_in.write(0x80004000);

    CCS_DESIGN(recursive_kvz_encode_coding_tree)(golden_cabac_write, config_in, golden_encode_intra_config, lcu, lcu_top, lcu_left);

    while (encode_intra_config.available(1)) {
      encode_config_val temp = encode_intra_config.read();
      encode_config_val golden_temp = golden_encode_intra_config.read();
      if (temp != golden_temp) {
        printf("Error: encode_intra_config");
        tests_passed = 0;
      }
    }
    while (cabac_write.available(1)) {
      cabac_val temp = cabac_write.read();
      cabac_val golden_temp = golden_cabac_write.read();
      if (temp != golden_temp) {
        printf("Error: cabac_write");
        tests_passed = 0;
      }
    }
  }

  if (RUN_TEST_CASE == 5 || RUN_TEST_CASE == 0) {
    for (int a = 0; a < 16 * 16; a++) {
      lcu[a] = lcu_golden5[a];
    }
    for (int a = 0; a < 16; a++) {
      lcu_top[a] = lcu_top_golden5[a];
      lcu_left[a] = lcu_left_golden5[a];
    }

    config_in.write(0x04380780);
    config_in.write(0x0);
    config_in.write(0x0);
    config_in.write(0x0);
    config_in.write(0x40404000);
    config_in.write(0x80004000);

    CCS_DESIGN(kvz_encode_coding_tree)
    (cabac_write, config_in, encode_intra_config, lcu, lcu_top, lcu_left, &low, &range, &buffered_byte, &num_buffered_bytes, &bits_left, &stream_data, &stream_cur_bit, &stream_zercount, cabac_metas);

    config_in.write(0x04380780);
    config_in.write(0x0);
    config_in.write(0x0);
    config_in.write(0x0);
    config_in.write(0x40404000);
    config_in.write(0x80004000);

    CCS_DESIGN(recursive_kvz_encode_coding_tree)(golden_cabac_write, config_in, golden_encode_intra_config, lcu, lcu_top, lcu_left);

    while (encode_intra_config.available(1)) {
      encode_config_val temp = encode_intra_config.read();
      encode_config_val golden_temp = golden_encode_intra_config.read();
      if (temp != golden_temp) {
        printf("Error: encode_intra_config");
        tests_passed = 0;
      }
    }
    while (cabac_write.available(1)) {
      cabac_val temp = cabac_write.read();
      cabac_val golden_temp = golden_cabac_write.read();
      if (temp != golden_temp) {
        printf("Error: cabac_write");
        tests_passed = 0;
      }
    }
  }

  if (tests_passed) {
    cout << "## SIMULATION PASSED ##" << endl;
  } else {
    cout << "## SIMULATION FAILED ##" << endl;
  }

  CCS_RETURN(0);
}